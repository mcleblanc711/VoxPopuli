"""Base strategy class and common types."""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import date
from enum import Enum
from typing import Any

import pandas as pd


class SignalType(Enum):
    """Type of trading signal."""

    LONG = "long"
    SHORT = "short"
    CLOSE = "close"
    HOLD = "hold"


@dataclass
class Signal:
    """Trading signal generated by a strategy."""

    date: date
    ticker: str
    signal_type: SignalType
    strength: float  # 0 to 1
    reason: str
    sentiment: float | None = None
    mentions: int | None = None
    metadata: dict = field(default_factory=dict)

    def to_dict(self) -> dict:
        """Convert to dictionary."""
        return {
            "date": self.date.isoformat() if isinstance(self.date, date) else str(self.date),
            "ticker": self.ticker,
            "signal_type": self.signal_type.value,
            "strength": self.strength,
            "reason": self.reason,
            "sentiment": self.sentiment,
            "mentions": self.mentions,
            "metadata": self.metadata,
        }


@dataclass
class Position:
    """Open position in the portfolio."""

    ticker: str
    entry_date: date
    entry_price: float
    shares: float
    direction: str  # 'long' or 'short'
    entry_sentiment: float | None = None
    stop_loss: float | None = None
    take_profit: float | None = None
    metadata: dict = field(default_factory=dict)

    @property
    def is_long(self) -> bool:
        return self.direction == "long"

    @property
    def is_short(self) -> bool:
        return self.direction == "short"

    def calculate_pnl(self, current_price: float) -> float:
        """Calculate current PnL."""
        if self.is_long:
            return (current_price - self.entry_price) * self.shares
        else:
            return (self.entry_price - current_price) * self.shares

    def calculate_return(self, current_price: float) -> float:
        """Calculate current return as decimal."""
        if self.is_long:
            return (current_price - self.entry_price) / self.entry_price
        else:
            return (self.entry_price - current_price) / self.entry_price

    def to_dict(self) -> dict:
        """Convert to dictionary."""
        return {
            "ticker": self.ticker,
            "entry_date": self.entry_date.isoformat() if isinstance(self.entry_date, date) else str(self.entry_date),
            "entry_price": self.entry_price,
            "shares": self.shares,
            "direction": self.direction,
            "entry_sentiment": self.entry_sentiment,
            "stop_loss": self.stop_loss,
            "take_profit": self.take_profit,
            "metadata": self.metadata,
        }


class BaseStrategy(ABC):
    """Abstract base class for trading strategies."""

    name: str = "base"
    description: str = "Base strategy"

    def __init__(
        self,
        position_size: float = 0.1,
        max_positions: int = 10,
        allow_shorts: bool = False,
        holding_period: int | None = None,
        stop_loss: float | None = None,
        take_profit: float | None = None,
        transaction_cost: float = 0.001,
        slippage: float = 0.0005,
        **kwargs: Any,
    ):
        """Initialize the strategy.

        Args:
            position_size: Fraction of capital per position (0-1).
            max_positions: Maximum number of concurrent positions.
            allow_shorts: Whether to allow short positions.
            holding_period: Fixed holding period in days (None = until exit signal).
            stop_loss: Stop loss percentage (e.g., 0.05 for 5%).
            take_profit: Take profit percentage.
            transaction_cost: Transaction cost as fraction.
            slippage: Slippage as fraction.
            **kwargs: Additional strategy-specific parameters.
        """
        self.position_size = position_size
        self.max_positions = max_positions
        self.allow_shorts = allow_shorts
        self.holding_period = holding_period
        self.stop_loss = stop_loss
        self.take_profit = take_profit
        self.transaction_cost = transaction_cost
        self.slippage = slippage
        self.params = kwargs

    @abstractmethod
    def generate_signals(
        self,
        sentiment_data: pd.DataFrame,
        price_data: dict[str, pd.DataFrame],
        current_date: date,
        positions: list[Position],
    ) -> list[Signal]:
        """Generate trading signals for the current date.

        Args:
            sentiment_data: DataFrame with sentiment data up to current_date.
            price_data: Dict of ticker -> price DataFrame.
            current_date: Current date in the backtest.
            positions: Current open positions.

        Returns:
            List of signals for the current date.
        """
        pass

    def should_exit(
        self,
        position: Position,
        current_date: date,
        current_price: float,
        sentiment: float | None = None,
    ) -> tuple[bool, str]:
        """Check if a position should be exited.

        Args:
            position: Current position.
            current_date: Current date.
            current_price: Current price.
            sentiment: Current sentiment (optional).

        Returns:
            Tuple of (should_exit, reason).
        """
        # Check holding period
        if self.holding_period:
            days_held = (pd.Timestamp(current_date) - pd.Timestamp(position.entry_date)).days
            if days_held >= self.holding_period:
                return True, "holding_period_expired"

        # Check stop loss
        if self.stop_loss:
            current_return = position.calculate_return(current_price)
            if current_return <= -self.stop_loss:
                return True, "stop_loss_hit"

        # Check take profit
        if self.take_profit:
            current_return = position.calculate_return(current_price)
            if current_return >= self.take_profit:
                return True, "take_profit_hit"

        return False, ""

    def calculate_position_size(
        self,
        capital: float,
        price: float,
        signal_strength: float = 1.0,
    ) -> float:
        """Calculate number of shares for a position.

        Args:
            capital: Available capital.
            price: Current price.
            signal_strength: Signal strength (0-1) to scale position.

        Returns:
            Number of shares.
        """
        position_value = capital * self.position_size * signal_strength
        # Account for transaction costs
        position_value *= (1 - self.transaction_cost - self.slippage)
        return position_value / price

    def get_config(self) -> dict:
        """Get strategy configuration as dict."""
        return {
            "name": self.name,
            "position_size": self.position_size,
            "max_positions": self.max_positions,
            "allow_shorts": self.allow_shorts,
            "holding_period": self.holding_period,
            "stop_loss": self.stop_loss,
            "take_profit": self.take_profit,
            "transaction_cost": self.transaction_cost,
            "slippage": self.slippage,
            "params": self.params,
        }

    def filter_sentiment_by_date(
        self,
        sentiment_data: pd.DataFrame,
        current_date: date,
        lookback_days: int = 1,
    ) -> pd.DataFrame:
        """Filter sentiment data to relevant date range.

        Args:
            sentiment_data: Full sentiment DataFrame.
            current_date: Current date.
            lookback_days: Days to look back.

        Returns:
            Filtered DataFrame.
        """
        end_date = pd.Timestamp(current_date)
        start_date = end_date - pd.Timedelta(days=lookback_days)

        date_col = "date" if "date" in sentiment_data.columns else "created_utc"
        dates = pd.to_datetime(sentiment_data[date_col])

        return sentiment_data[(dates >= start_date) & (dates <= end_date)]
